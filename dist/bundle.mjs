const r=Symbol("Placeholder"),t=t=>{let e=0;for(const n of t)n!==r&&e++;return e},e=(t,e)=>{const n=t.length,o=t.slice(),c=e.length;let s=c,u=0;for(;s&&u<n;u++)o[u]===r&&(o[u]=e[c-s],s--);for(u=n;s;u++,s--)o[u]=e[c-s];return o},n=(r,o,c)=>{const s=r.length-o.length-t(c);if(s<1)return r(...e(o,c));{const t=(...t)=>n(r,e(o,c),t);return t.$args_left=s,t}},o=r=>(...e)=>r.length>t(e)?n(r,[],e):r(...e),c=t=>function(e){return e===r?t:t(e)};function s(t){return function(e,n){const o=e===r,s=arguments.length;if(1===s&&o)throw new Error("Senseless placeholder usage.");return arguments.length>1?o?c((r=>t(r,n))):t(e,n):r=>t(e,r)}}function u(r){return o(r)}const l=void 0,f=1/0,i=r=>typeof r,a=r=>null===r,h={u:"U",b:"B",n:"N",s:"S",f:"F"},g=r=>{const t=i(r);return"object"===t?a(r)?"Null":r.constructor.name:h[t[0]]+t.slice(1)},b=s(((r,t)=>(t.push(r),t))),p=u(((r,t,e)=>e.reduce(r,t))),d=u(((r,t,e)=>{for(let n in e)switch(g(e[n])){case"Array":if(r>1&&"Array"===g(t[n]))switch(r){case 2:const o=t[n],c=e[n];for(const t in c)o[t]?d(r,o[t],c[t]):o[t]=c[t];break;case 3:t[n].push(...e[n])}else t[n]=e[n];break;case"Object":if("Object"===g(t[n])){d(r,t[n],e[n]);break}default:t[n]=e[n]}return t}));d(1),d(2),d(3);const m=s(((r,t)=>{const e=g(r);if(e===g(t)&&("Object"===e||"Array"==e)){if(a(r)||a(t))return r===t;if(r===t)return!0;for(const e of[r,t])for(const n in e)if(!(e===t&&n in r||e===r&&n in t&&m(r[n],t[n])))return!1;return!0}return r===t})),y=o(((r,t,e,n)=>r(n)?t(n):e(n))),w=(...t)=>(...e)=>{let n,o=!0;for(let c=k(t)-1;c>-1;c--)o?(o=!1,n=t[c](...e)):n=n===r?t[c]():t[c](n);return n},j=s(((r,t)=>t[r])),A=s(((r,t)=>{if((r=>"string"===i(r))(t))return t.includes(r);for(const e of t)if(m(e,r))return!0;return!1})),N=u(((r,t,e)=>e.slice(r,(r=>"number"==i(r))(t)?t:f))),S=j(0);N(1,f);const O=r=>a(r)||(r=>r===l)(r),k=r=>r.length,B=r=>()=>r,E=s(((r,t)=>t.split(r))),q=r=>p(((r,t)=>A(t,r)?r:b(t,r)),[],r),v=u(((r,t,e)=>({...e,[r]:t}))),x=s(((r,t)=>t[r])),C=u(((r,t,e)=>y(k,(()=>O(e)?r:w(y(O,B(r),(e=>C(r,N(1,f,t),e))),(r=>s(((t,e)=>r(e,t))))(x)(e),S)(t)),B(e),t)));C(l);const F=/^(.*?)(8|16|32|64)(Clamped)?Array$/,I=(r,t=!1)=>{const e=g(r);switch(e){case"Null":case"String":case"Number":case"Boolean":case"Symbol":return r;case"Array":return t?[...r]:P(w(I,(r=>(...t)=>t[r])(0)),r);case"Object":if(t)return{...r};const n={};for(let t in r)n[t]=I(r[t]);return n;default:return F.test(e)?r.constructor.from(r):r}},M=u(((r,t,e)=>p(r,I(t),e))),P=s(((r,t)=>t.map(r))),{floor:U}=Math;let $,z,D,G;const H=w((r=>M(((r,t)=>v(...t,r)),{},r)),P(((r,t)=>[r,t])),E("")),J=(r,t=!1)=>{if(!(r=>w(m(k(r)),k,q,E(""))(r))(r))throw new Error("Not all chars are unique!");$=r,z=$.length,G=t&&z<37,D=H($)};J("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",!0);const K=r=>{let t="";for(;r>0;)t=$[r%z]+t,r=U(r/z);return t||"0"},L=r=>{if(G)return parseInt(r,z);const t=r.length;let e=0;for(let n=0;n<t;n++)e+=D[r[n]]*z**(t-n-1);return e};export{J as setABC,L as unzipnum,K as zipnum};
