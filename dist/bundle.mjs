const r=Symbol("Placeholder"),t=t=>{let e=0;for(const n of t)n!==r&&e++;return e},e=(t,e)=>{const n=t.length,o=t.slice(),s=e.length;let c=s,u=0;for(;c&&u<n;u++)o[u]===r&&(o[u]=e[s-c],c--);for(u=n;c;u++,c--)o[u]=e[s-c];return o},n=(r,o,s)=>{const c=r.length-o.length-t(s);if(c<1)return r(...e(o,s));{const t=(...t)=>n(r,e(o,s),t);return t.$args_left=c,t}},o=r=>(...e)=>r.length>t(e)?n(r,[],e):r(...e),s=t=>function(e){return e===r?t:t(e)};function c(t){return function(e,n){const o=e===r,c=arguments.length;if(1===c&&o)throw new Error("Senseless placeholder usage.");return arguments.length>1?o?s((r=>t(r,n))):t(e,n):r=>t(e,r)}}function u(r){return o(r)}const l=void 0,f=1/0,i=r=>typeof r,a=r=>null===r,h={u:"U",b:"B",n:"N",s:"S",f:"F"},g=r=>{const t=i(r);return"object"===t?a(r)?"Null":r.constructor.name:h[t[0]]+t.slice(1)},b=c(((r,t)=>(t.push(r),t))),p=u(((r,t,e)=>e.reduce(r,t))),d=u(((r,t,e)=>{for(let n in e)switch(g(e[n])){case"Array":if(r>1&&"Array"===g(t[n]))switch(r){case 2:const o=t[n],s=e[n];for(const t in s)o[t]?d(r,o[t],s[t]):o[t]=s[t];break;case 3:t[n].push(...e[n])}else t[n]=e[n];break;case"Object":if("Object"===g(t[n])){d(r,t[n],e[n]);break}default:t[n]=e[n]}return t}));d(1),d(2),d(3);const m=c(((r,t)=>{const e=g(r);if(e===g(t)&&("Object"===e||"Array"==e)){if(a(r)||a(t))return r===t;if(r===t)return!0;for(const e of[r,t])for(const n in e)if(!(e===t&&n in r||e===r&&n in t&&m(r[n],t[n])))return!1;return!0}return r===t})),y=o(((r,t,e,n)=>r(n)?t(n):e(n))),w=(...t)=>(...e)=>{let n,o=!0;for(let s=k(t)-1;s>-1;s--)o?(o=!1,n=t[s](...e)):n=n===r?t[s]():t[s](n);return n},j=c(((r,t)=>t[r])),A=c(((r,t)=>{if((r=>"string"===i(r))(t))return t.includes(r);for(const e of t)if(m(e,r))return!0;return!1})),N=u(((r,t,e)=>e.slice(r,(r=>"number"==i(r))(t)?t:f))),S=j(0);N(1,f);const O=r=>a(r)||(r=>r===l)(r),k=r=>r.length,B=r=>()=>r,E=c(((r,t)=>t.split(r))),q=r=>p(((r,t)=>A(t,r)?r:b(t,r)),[],r),v=u(((r,t,e)=>({...e,[r]:t}))),x=c(((r,t)=>t[r])),C=u(((r,t,e)=>y(k,(()=>O(e)?r:w(y(O,B(r),(e=>C(r,N(1,f,t),e))),(r=>c(((t,e)=>r(e,t))))(x)(e),S)(t)),B(e),t)));C(l);const F=/^(.*?)(8|16|32|64)(Clamped)?Array$/,I=(r,t=!1)=>{const e=g(r);switch(e){case"Null":case"String":case"Number":case"Boolean":case"Symbol":return r;case"Array":return t?[...r]:P(w(I,(r=>(...t)=>t[r])(0)),r);case"Object":if(t)return{...r};const n={};for(let t in r)n[t]=I(r[t]);return n;default:return F.test(e)?r.constructor.from(r):r}},M=u(((r,t,e)=>p(r,I(t),e))),P=c(((r,t)=>t.map(r))),{floor:U}=Math;let W,$,z,D,G="0123456789abcdefghijklmnopqrstuvwxyz";const H=w((r=>M(((r,t)=>v(...t,r)),{},r)),P(((r,t)=>[r,t])),E("")),J=r=>{if(!(r=>w(m(k(r)),k,q,E(""))(r))(r))throw new Error("Not all chars are unique!");W=r,$=W.length,D=(r=>G.startsWith(r))(W),z=H(W)};J(G+"ABCDEFGHIJKLMNOPQRSTUVWXYZ");const K=r=>{let t="";for(;r>0;)t=W[r%$]+t,r=U(r/$);return t||"0"},L=r=>{if(D)return parseInt(r,$);const t=r.length;let e=0;for(let n=0;n<t;n++)e+=z[r[n]]*$**(t-n-1);return e};export{J as setABC,L as unzipnum,K as zipnum};
