"use strict";const r=Symbol("Placeholder"),t=t=>{let e=0;for(const n of t)n!==r&&e++;return e},e=(t,e)=>{const n=t.length,o=t.slice(),s=e.length;let c=s,u=0;for(;c&&u<n;u++)o[u]===r&&(o[u]=e[s-c],c--);for(u=n;c;u++,c--)o[u]=e[s-c];return o},n=(r,o,s)=>{const c=r.length-o.length-t(s);if(c<1)return r(...e(o,s));{const t=(...t)=>n(r,e(o,s),t);return t.$args_left=c,t}},o=r=>(...e)=>r.length>t(e)?n(r,[],e):r(...e),s=t=>function(e){return e===r?t:t(e)};function c(t){return function(e,n){const o=e===r,c=arguments.length;if(1===c&&o)throw new Error("Senseless placeholder usage.");return arguments.length>1?o?s((r=>t(r,n))):t(e,n):r=>t(e,r)}}function u(r){return o(r)}const l=void 0,f=1/0,i=r=>typeof r,a=r=>null===r,h={u:"U",b:"B",n:"N",s:"S",f:"F"},g=r=>{const t=i(r);return"object"===t?a(r)?"Null":r.constructor.name:h[t[0]]+t.slice(1)},b=c(((r,t)=>(t.push(r),t))),p=u(((r,t,e)=>e.reduce(r,t))),m=u(((r,t,e)=>{for(let n in e)switch(g(e[n])){case"Array":if(r>1&&"Array"===g(t[n]))switch(r){case 2:const o=t[n],s=e[n];for(const t in s)o[t]?m(r,o[t],s[t]):o[t]=s[t];break;case 3:t[n].push(...e[n])}else t[n]=e[n];break;case"Object":if("Object"===g(t[n])){m(r,t[n],e[n]);break}default:t[n]=e[n]}return t}));m(1),m(2),m(3);const d=c(((r,t)=>{const e=g(r);if(e===g(t)&&("Object"===e||"Array"==e)){if(a(r)||a(t))return r===t;if(r===t)return!0;for(const e of[r,t])for(const n in e)if(!(e===t&&n in r||e===r&&n in t&&d(r[n],t[n])))return!1;return!0}return r===t})),y=o(((r,t,e,n)=>r(n)?t(n):e(n))),w=(...t)=>(...e)=>{let n,o=!0;for(let s=k(t)-1;s>-1;s--)o?(o=!1,n=t[s](...e)):n=n===r?t[s]():t[s](n);return n},A=c(((r,t)=>t[r])),j=c(((r,t)=>{if((r=>"string"===i(r))(t))return t.includes(r);for(const e of t)if(d(e,r))return!0;return!1})),N=u(((r,t,e)=>e.slice(r,(r=>"number"==i(r))(t)?t:f))),S=A(0);N(1,f);const O=r=>a(r)||(r=>r===l)(r),k=r=>r.length,x=r=>()=>r,B=c(((r,t)=>t.split(r))),z=r=>p(((r,t)=>j(t,r)?r:b(t,r)),[],r),C=u(((r,t,e)=>({...e,[r]:t}))),E=c(((r,t)=>t[r])),q=u(((r,t,e)=>y(k,(()=>O(e)?r:w(y(O,x(r),(e=>q(r,N(1,f,t),e))),(r=>c(((t,e)=>r(e,t))))(E)(e),S)(t)),x(e),t)));q(l);const v=/^(.*?)(8|16|32|64)(Clamped)?Array$/,F=(r,t=!1)=>{const e=g(r);switch(e){case"Null":case"String":case"Number":case"Boolean":case"Symbol":return r;case"Array":return t?[...r]:M(w(F,(r=>(...t)=>t[r])(0)),r);case"Object":if(t)return{...r};const n={};for(let t in r)n[t]=F(r[t]);return n;default:return v.test(e)?r.constructor.from(r):r}},I=u(((r,t,e)=>p(r,F(t),e))),M=c(((r,t)=>t.map(r))),{floor:P}=Math;let U,W,$,D,G="0123456789abcdefghijklmnopqrstuvwxyz";const H=w((r=>I(((r,t)=>C(...t,r)),{},r)),M(((r,t)=>[r,t])),B("")),J=r=>{if(!(r=>w(d(k(r)),k,z,B(""))(r))(r))throw new Error("Not all chars are unique!");U=r,W=U.length,D=(r=>G.startsWith(r))(U),$=H(U)};J(G+"ABCDEFGHIJKLMNOPQRSTUVWXYZ");exports.setABC=J,exports.unzipnum=r=>{if(D)return parseInt(r,W);const t=r.length;let e=0;for(let n=0;n<t;n++)e+=$[r[n]]*W**(t-n-1);return e},exports.zipnum=r=>{let t="";for(;r>0;)t=U[r%W]+t,r=P(r/W);return t||"0"};
